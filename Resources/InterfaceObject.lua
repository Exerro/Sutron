-- Core valueslocal function linewrap( str, len )	for i = 1,len do		if str:sub( i, i ) == "\n" then			return str:sub( 1, i - 1 ).." ", str:sub( i+1, str:len( ) )		end	end	if str:len( ) <= len then return str, "" end	if str:sub( len+1, len+1 ) == " " then		return str:sub( 1, len ), str:sub( len+1, str:len( ) )	end	for i = len, 1, -1 do		if str:sub( i, i ) == " " then			return str:sub( 1, i ), str:sub( i+1, str:len( ) )		end	end	return str:sub( 1, len ), str:sub( len+1, str:len( ) )endwordwrap = function( str, len, h )	local wrap	local lines = { }	while str ~= "" and ( not h or #lines < h ) do		wrap, str = linewrap( str, len )		table.insert( lines, wrap )	end	while h and #lines > h do		table.remove( lines, #lines )	end	return linesendlocal miscObject = {	getParent = function( self )		return self.data.Parent	end;	getRootParent = function( self )		local t = self		while t.data.Parent do			t = t.data.Parent		end		return t	end;	getParentByType = function( self, _type )		local t = self		while t.data.Parent do			if t.data.Parent.data.type == _type then				return t.data.Parent			end			t = t.data.Parent		end		return false	end;	getParentValues = function( self, val )		local getVal		getVal = function( self, val )			local t = { }			if self.data.Parent then				t = getVal( self.data.Parent, val )			end			table.insert( t, p.data[val] )			return t		end		return getVal( self, val )	end;	getParentNumberValues = function( self, val )		local getParentVal		getParentVal = function( p, val )			if p.data.Parent then				return getParentVal( p.data.Parent, val ) + p.data[val]			end			return p.data[val]		end		return getParentVal( self, val )	end;	getParentChild = function( self, parent ) -- used for finding a root parent that is one down from a main root parent		local findChild		findChild = function( parent, self )			for i = 1,#parent.data.Children do				if parent.data.Children[i] == self then					return true				end				if parent.data.Children[i].data.Children then					for k = 1,#parent.data.Children[i].data.Children do						if findChild( parent.data.Children[i].data.Children[k], self ) then							return true						end					end				end			end			return false		end		for i = 1,#parent.data.Children do			if findChild( parent.data.Children[i], self ) then				return parent.data.Children[i]			end		end		return false	end;	--[[ i.e, you have Parent(child1(child1(child1,child2),child2)child2(child1))	you have the handle for Parent.child1.child1.child2 and the handle for Parent	you want to get Parent.child1 and remove it for some reason	you would use self:getParentChild( Parent ):remove( )	]]	setX = function( self, x )		self.data.x = x		if self.data.solid then			if self.data.x < 1 then				self.data.x = 1			end			if self.data.Parent and self.data.x + self.data.w > self.data.Parent.data.w then				self:setWidth( self.data.Parent.data.w - self.data.x + 1 )			end		end	end;	setY = function( self, y )		self.data.y = y		if self.data.solid then			if self.data.y < 1 then				self.data.y = 1			end			if self.data.Parent and self.data.y + self.data.h > self.data.Parent.data.h then				self:setHeight( self.data.Parent.data.h - self.data.y + 1 )			end		end	end;	move = function( self, mode, x, y )		if mode == "add" then			x = x + self.data.x			y = y + self.data.y		elseif mode ~= "set" then			error( "Mode expected: [set,add]. Got "..type( mode ).." "..tostring( mode ), 2 )		end		self:setX( x )		self:setY( y )	end;	setWidth = function( self, w )		self.data.w = w		if self.data.w < 1 then			self.data.w = 1		end		if self.data.solid then			if self.data.Parent and self.data.x + self.data.w - 1 > self.data.Parent.data.w then				self.data.w = self.data.Parent.data.w - self.data.x + 1			end		end		if self.data.Children then			for k, v in pairs( self.data.Children ) do				if v.data.solid then					if v.data.x + v.data.w > self.data.w then						v:setWidth( self.data.w - v.data.x + 1 )					end					if v.data.x + v.data.w > self.data.w then						self.data.w = v.data.x + v.data.w - 1					end				end			end		end	end;	setHeight = function( self, h )		self.data.h = h		if self.data.h < 1 then			self.data.h = 1		end		if self.data.solid then			if self.data.Parent and self.data.y + self.data.h - 1 > self.data.Parent.data.h then				self.data.h = self.data.Parent.data.h - self.data.y + 1			end		end		if self.data.Children then			for k, v in pairs( self.data.Children ) do				if v.data.solid then					if v.data.y + v.data.h > self.data.h then						v:setHeight( self.data.h - v.data.y + 1 )					end					if v.data.y + v.data.h > self.data.h then						self.data.h = v.data.y + v.data.h - 1					end				end			end		end	end;	resize = function( self, mode, w, h )		if mode == "add" then			w = w + self.data.w			h = h + self.data.h		elseif mode ~= "set" then			error( "Mode expected: [set,add]. Got "..type( mode ).." "..tostring( mode ), 2 )		end		self:setWidth( w )		self:setHeight( h )	end;		getX = function( self, real )		if not real then return self.data.x end		return self:getParentNumberValues( "x" ) - self.data.Layer	end;	getY = function( self, real )		if not real then return self.data.y end		return self:getParentNumberValues( "y" ) - self.data.Layer	end;	getPosition = function( self, real )		return self:getX( real ), self:getY( real )	end;		getWidth = function( self )		return self.data.w	end;	getHeight = function( self )		return self.data.h	end;	getSize = function( self )		return self:getWidth( ), self:getHeight( )	end;		setSolid = function( self, bool ) -- solid is used for auto resizing based on parent size		self.data.solid = not not bool	end;	isSolid = function( self )		return self.data.solid	end;	setID = function( self, id )		self.data.UID = id or self.data.UID	end;	getType = function( self )		return self.data.type	end;	activate = function( self )		self.data.active = true	end;	deactivate = function( self )		self.data.active = false	end;	toggleActive = function( self )		self.data.active = not self.data.active	end;	isActive = function( self )		return self.data.active	end;	remove = function( self )		self:deactivate( )		local i = self.data.Parent:getChildIndex( self )		if i then			table.remove( self.data.Parent.data.Children, i )		end	end;}local function newObject( Parent, _type, x, y, w, h )	local o = { }	o.data = {		type = _type;		x = 1;		y = 1;		w = 1;		h = 1;		Parent = Parent or false;		Layer = Parent and Parent.data.Layer + 1 or 0;		UID = "UNDEFINED";		active = true;		solid = true;	}	setmetatable( o, { __index = miscObject } )	o:move( "set", x or 1, y or 1 )	o:resize( "set", w or 1, h or 1 )	return oendlocal objectTypeslocal function newFrame( Parent )	local o = newObject( Parent, "Frame", 1, 1, 1, 1 )	o.data.Children = { }	o.newChild = function( self, Child )		table.insert( self.data.Children, Child )		Child.data.Parent = self		Child.data.Layer = self.data.Layer + 1		return Child	end	o.newFrame = function( self, x, y, w, h )		local frame = self:newChild( newFrame( self.data.Parent ) )		if x then			frame:setX( x )		end		if y then			frame:setY( y )		end		if w then			frame:setW( w )		end		if h then			frame:setH( h )		end		return frame	end	o.newObject = function( self, type )		if objectTypes[type] then			local child = objectTypes[type]:create( self )			self:newChild( child )			child.focusOn = function( self )				self.data.Parent:focus( self )			end			return child		end		return false	end	o.getChildren = function( self )		return self.data.Children	end	o.getActiveChildren = function( self )		local t = { }		for i = 1,#self.data.Children do			if self.data.Children[i].data.active then				table.insert( t, self.data.Children[i] )			end		end		return t	end	o.getChildByIndex = function( self, index )		return self.data.Children[index]	end	o.getChildByID = function( self, id )		local options = { }		for i, v in pairs( self:getActiveChildren( ) ) do			if v.data.UID == id then				table.insert( options, v )			end		end		if #options == 0 then return false, { } end		if #options == 1 then return "One", options[1] end		return "Multiple", options	end	o.getChildByType = function( self, type )		local options = { }		for i, v in pairs( self:getActiveChildren( ) ) do			if v.data.type == type then				table.insert( options, v )			end		end		if #options == 0 then return false, { } end		if #options == 1 then return "One", options[1] end		return "Multiple", options	end	o.getFirstChildByID = function( self, id )		local sel, options = self:getChildByID( id )		if not sel then return false end		if sel == "One" then return options end		return options[1]	end	o.getFirstChildByType = function( self, _type )		local sel, options = self:getChildByType( _type )		if not sel then return false end		if sel == "One" then return options end		return options[1]	end	o.getChildIndex = function( self, child )		for i = 1,#self.data.Children do			if self.data.Children[i] == child then				return i			end		end		return false	end	o.focus = function( self, child )		if type( child ) == "table" then			for k, v in pairs( self.data.Children ) do				if v == child then					child = k				end			end		end		if type( child ) == "table" then return false end -- it would be a table if it didn't find a matching child in the above loop		table.insert( self.data.Children, self.data.Children[child] ) -- switcheroo		table.remove( self.data.Children, child )		if self.data.Parent then			self.data.Parent:focus( self )		end	end	o.update = function( self, ev, ... )		if not self.data.active then return false end		local mev = { }		for k, v in pairs( ev ) do			mev[k] = v		end		local modified = false		if type( self.data.update ) == "function" then			local ok, data = pcall( self.data.update, self, ev, ... )			if ok and data then				mev = data				modified = true			elseif not ok then				error( data, 0 )			end		end		if mev[1] == "Cancel" and modified then return false end		for i = #self.data.Children, 1, -1 do			local ok, err = pcall( self.data.Children[i].update, self.data.Children[i], mev, ... )			if not ok then				error( err, 0 )			end		end		return true	end	o.render = function( self )		if not self.data.active then return false end		local ok = true		if type( self.data.render ) == "function" then			ok = self.data.render( ) -- return false to cancel, true to continue, nil to continue			if ok == nil then ok = true end		end		if not ok then return false end		for i = 1,#self.data.Children do			self.data.Children[i]:render( )		end		return true	end	return oendobjectTypes = {	["Button"] = {		data = {			update = function( self, ev )				if not self.data.active then return false end				local x, y = self:getX( true ), self:getY( true )				if ev[1] == "Mouse" and ev[2] == "Click" and ev[8] == self then					if ev[4] >= x and ev[5] >= y and ev[4] < x + self:getWidth( ) and ev[5] < y + self:getHeight( ) then						if type( self.onClick ) == "function" then							self:onClick( ev[3], ev[4], ev[5], ev[4] - x + 1, ev[5] - y + 1 )						end						self:focusOn( )					end				end			end;			render = function( self )				if not self.data.active then return false end				local x, y = self:getPosition( true )				term.setBackgroundColour( self.data.colour or 1 )				for yy = y, y + self:getHeight( ) - 1 do					term.setCursorPos( x, yy )					term.write( string.rep( " ", self:getWidth( ) ) )				end				term.setCursorPos( x, y )				term.write( self.data.text )				term.setBackgroundColour( 32768 )			end;			handlesMouse = true;		};		create = function( self, Parent )			local object = newObject( Parent, "ButtonObject" )			for k, v in pairs( self.data ) do				if k ~= "update" and k ~= "render" then					object.data[k] = v				end			end			object.update = self.data.update			object.render = self.data.render			return object		end;	};	["Textbox"] = {		data = {			update = function( self, ev )				if not self.data.active then return false end				if ev[1] == "Keyboard" and self.data.focussed then					if ev[2] == "Key" then						if ev[4] == "left" then							if self.data.cursorPos > 1 then								self.data.cursorPos = self.data.cursorPos - 1							end						elseif ev[4] == "right" then							if self.data.cursorPos <= #self.data.text then								self.data.cursorPos = self.data.cursorPos + 1							end						elseif ev[4] == "up" then							local x, y = self:getCursorPosXY( )							if y > 1 then								self.data.cursorPos = self:getCursorXYPos( x, y - 1 )							else								self.data.cursorPos = 1							end						elseif ev[4] == "down" then							local x, y = self:getCursorPosXY( )							self.data.cursorPos = math.min( self:getCursorXYPos( x, y + 1 ), #self.data.text + 1 )						elseif ev[4] == "backspace" then							self.data.text = self.data.text:sub( 1, self.data.cursorPos - 2 )..self.data.text:sub( self.data.cursorPos )							self.data.cursorPos = math.max( self.data.cursorPos - 1, 1 )						elseif ev[4] == "enter" then							self.data.text = self.data.text:sub( 1, self.data.cursorPos - 1 ).."\n"..self.data.text:sub( self.data.cursorPos )							self.data.cursorPos = self.data.cursorPos + 1						elseif ev[4] == "delete" then							self.data.text = self.data.text:sub( 1, self.data.cursorPos - 1 )..self.data.text:sub( self.data.cursorPos + 1 )						end					elseif ev[2] == "Char" then						self.data.text = self.data.text:sub( 1, self.data.cursorPos - 1 )..ev[4]..self.data.text:sub( self.data.cursorPos )						self.data.cursorPos = self.data.cursorPos + 1					end				elseif ev[1] == "Mouse" and ev[2] == "Click" and ev[8] == self then					if self.data.focussed then						local x, y = ev[4] - self:getX( true ) + 1, ev[5] - self:getY( true ) + 1						self.data.cursorPos = self:getCursorXYPos( x, y )					else						self.data.focussed = true						self:focusOn( )					end				elseif ev[1] == "Mouse" and ev[2] == "Click" then					self.data.focussed = false				end			end;			render = function( self )				if not self.data.active then return false end				local x, y = self:getPosition( true )				term.setBackgroundColour( self.data.colour or ( self.data.focussed and 1 or colours.lightGrey ) )				term.setTextColour( self.data.tcolour or 32768 )				local lines = wordwrap( self.data.text, self:getWidth( ), self:getHeight( ) )				for yy = 1, self:getHeight( ) do					term.setCursorPos( x, y + yy - 1 )					local line = ( lines[yy] and lines[yy]:sub( 1, self:getWidth( ) ) ) or ""					term.write( line..string.rep( " ", self:getWidth( ) - #line ) )				end				if self.data.focussed then					local rp = self:getParentByType( "Interface" )					local x, y = self:getCursorPosXY( lines )					local rx, ry = self:getX( true ) + x - 1, self:getY( true ) + y - 1					term.setCursorPos( rx, ry )					rp.data.ex, rp.data.ey, rp.data.cb = rx, ry, true					term.setCursorBlink( true )				end				term.setBackgroundColour( 32768 )			end;			text = "Hello World\nHow are you";			cursorPos = 1;			handlesMouse = true;			handlesKeys = true;			focussed = false;		};		getCursorPosXY = function( self, lines )			local lines = lines or wordwrap( self.data.text, self:getWidth( ), self:getHeight( ) )			local x, y = 1, 0			local len = 0			local cp = self.data.cursorPos			for i = 1,#lines do				y = y + 1				len = len + #lines[i]				cp = cp - #lines[i]				if len >= self.data.cursorPos then					return cp + #lines[i], y				end				if i == #lines then					return #lines[i] + 1, y				end			end			return 1, 1		end;		getCursorXYPos = function( self, x, y, lines )			local lines = lines or wordwrap( self.data.text, self:getWidth( ), self:getHeight( ) )			local len = 0			if #lines == 0 or lines[1] == "" then return 1 end			for i = 1,#lines do				if i == y then					return len + x				end				len = len + #lines[i]			end			return len + 1		end;		create = function( self, Parent )			local object = newObject( Parent, "TextboxObject" )			for k, v in pairs( self.data ) do				if k ~= "update" and k ~= "render" then					object.data[k] = v				end			end			object.update = self.data.update			object.render = self.data.render			object.getCursorXYPos = self.getCursorXYPos			object.getCursorPosXY = self.getCursorPosXY			return object		end;	};	["Flicker"] = { -- testing object, it doesn't really have a purpose other than demonstrating the capabilities of the system...		data = {			update = function( self, ev )				if not self.data.active then return false end				if ev[1] == "update" and self.data.running then					self.data.ci = self.data.ci + 1					if self.data.ci > 15 then self.data.ci = 0 end					self.data.colour = 2 ^ self.data.ci				elseif ev[1] == "Mouse" and ev[2] == "Click" and ev[8] == self then					self.data.running = not self.data.running				end			end;			render = function( self )				if not self.data.active then return false end				local x, y = self:getPosition( true )				term.setBackgroundColour( self.data.colour or 1 )				for yy = y, y + self.data.h - 1 do					term.setCursorPos( x, yy )					term.write( string.rep( " ", self.data.w ) )				end				term.setBackgroundColour( 32768 )			end;			ci = 0;			running = true;			handlesMouse = true;		};		create = function( self, Parent )			local object = newObject( Parent, "FlickerObject" )			for k, v in pairs( self.data ) do				if k ~= "update" and k ~= "render" then					object.data[k] = v				end			end			object.update = self.data.update			object.render = self.data.render			return object		end;	};	["Canvas"] = { -- testing object, used for me to determine whether making a windowing OS would be possible using dragable objects		data = {			update = function( self, ev )				if not self.data.active then return false end				local x, y = self:getPosition( true )				local w, h = self:getSize( )				for y = 1,h do					self.data.canvas[y] = self.data.canvas[y] or { }					for x = 1,w do						self.data.canvas[y][x] = self.data.canvas[y][x] or false					end				end				if ev[1] == "Mouse" and ev[2] == "Click" and not ev[6] and ev[8] == self then					local rx, ry = ev[4] - x + 1, ev[5] - y + 1					self.data.canvas[ry][rx] = not self.data.canvas[ry][rx]					self:focusOn( )				end			end;			render = function( self )				if not self.data.active then return false end				local x, y = self:getPosition( true )				term.setBackgroundColour( self.data.colour or 1 )				for yy = y, y + self:getHeight( ) - 1 do					term.setCursorPos( x, yy )					term.write( string.rep( " ", self:getWidth( ) ) )				end				term.setBackgroundColour( colours.blue )				for i, v in ipairs( self.data.canvas ) do					for ii, vv in ipairs( v ) do						if vv then							term.setCursorPos( x + ii - 1, y + i - 1 )							term.write( " " )						end					end				end				term.setCursorPos( x, y )				term.write( self.data.text )				term.setBackgroundColour( 32768 )			end;			canvas = { };			handlesMouse = true;		};		create = function( self, Parent )			local object = newObject( Parent, "ButtonObject" )			for k, v in pairs( self.data ) do				if k ~= "update" and k ~= "render" then					object.data[k] = v				end			end			object.update = self.data.update			object.render = self.data.render			return object		end;	};	["Dragable"] = {		data = {			update = function( self, ev, lastEvent )				if not self.data.active then return false end				local mev = { }				for k, v in pairs( ev ) do					mev[k] = v				end				if ev[1] == "Mouse" and ev[2] == "Click" and not self.data.dragging and self.data.Children[self:getChildIndex( ev[8] )] then					self.data.dragging = true					mev[6] = true -- allows the children to know whether the event made the parent move					self:focusOn( )				elseif ev[1] == "Mouse" and ev[2] == "Drag" and self.data.dragging and lastEvent and self.data.Children[self:getChildIndex( lastEvent[8] )] then					local x, y = ev[6], ev[7]					if self.data.direction then						if self.data.direction:sub( 1, 1 ) == "x" then							y = 0							if self.data.direction:sub( 2, 2 ) == "-" and x > 0 then								x = 0							elseif self.data.direction:sub( 2, 2 ) == "+" and x < 0 then								x = 0							end						elseif self.data.direction:sub( 1, 1 ) == "y" then							x = 0							if self.data.direction:sub( 2, 2 ) == "-" and y > 0 then								y = 0							elseif self.data.direction:sub( 2, 2 ) == "+" and y < 0 then								y = 0							end						end					end					self:move( "add", x, y )					if type( self.onDrag ) == "function" then						self:onDrag( x, y, self:getPosition( ) )					end				elseif ev[1] ~= "update" then					self.data.dragging = false				end				for i = #self.data.Children, 1, -1 do					local ok, err = pcall( self.data.Children[i].update, self.data.Children[i], mev, lastEvent )					if not ok then						error( err, 0 )					end				end			end;			render = function( self )				if not self.data.active then return false end				for i = 1,#self.data.Children do					self.data.Children[i]:render( )				end				--[[local x, y = self:getPosition( true )				term.setBackgroundColour( colours.lime )				for yy = y, y + self.data.h - 1 do					term.setCursorPos( x, yy )					term.write( string.rep( " ", self.data.w ) )				end]]				term.setBackgroundColour( 32768 )			end;			setDirection = function( self, dir )				if dir and ( dir:sub( 1, 1 ) == "x" or dir:sub( 1, 1 ) == "y" ) then					if dir:sub( 2, 2 ) == "" or dir:sub( 2, 2 ) == "+" or dir:sub( 2, 2 ) == "-" then						self.data.direction = dir					end				end			end;			getDirection = function( self )				return self.data.direction			end;			direction = false;			dragging = false;		};		create = function( self, Parent )			local frame = newFrame( Parent, "DragableFrame" )			for k, v in pairs( self.data ) do				if k ~= "update" and k ~= "render" and k ~= "setDirection" and k ~= "getDirection" then					frame.data[k] = v				end			end			frame.update = self.data.update			frame.render = self.data.render			frame.setDirection = self.data.setDirection			frame.getDirection = self.data.getDirection			return frame		end;	};	["Row"] = {		create = function( self, Parent )			local frame = newFrame( Parent )			frame.data.type = "RowFrame"			frame.sort = function( self )				local x = 1				for i = 1, #self.data.Children do					self.data.Children[i]:move( "set", x, 1 )					self.data.Children[i]:setHeight( self.data.h )					x = x + self.data.Children[i].data.w				end			end			frame.unpack = function( self )				local t = { }				for i = 1,#self.data.Children do					local p = self.data.Parent:newChild( self.data.Children[i] )					p:move( "add", self:getX( ) - 1, self:getY( ) - 1 )					table.insert( t, p )				end				local i = self.data.Parent:getChildIndex( self )				if i then					table.remove( self.data.Parent.data.Children, i )				end				t.remove = function( self )					for i = 1,#self do						self:deactivate( )					end				end				return t			end			return frame		end;	};	["Column"] = {		create = function( self, Parent )			local frame = newFrame( Parent )			frame.data.type = "ColumnFrame"			frame.sort = function( self )				local y = 1				for i = 1, #self.data.Children do					self.data.Children[i]:move( "set", 1, y )					self.data.Children[i]:setWidth( self.data.w )					y = y + self.data.Children[i].data.h				end			end			frame.unpack = function( self )				local t = { }				for i = 1,#self.data.Children do					local p = self.data.Parent:newChild( self.data.Children[i] )					p:move( "add", self:getX( ) - 1, self:getY( ) - 1 )					table.insert( t, p )				end				local i = self.data.Parent:getChildIndex( self )				if i then					table.remove( self.data.Parent.data.Children, i )				end				t.remove = function( self )					for i = 1,#self do						self[i]:deactivate( )					end				end				return t			end			return frame		end;	};}-- Exposed functionsfunction newInterface( x, y, w, h )	local frame = newFrame( )	frame:move( "set", x, y )	frame:resize( "set", w, h )	frame.update = function( self, ev )		if not self.data.active then return false end		local mev = { }		if ev[1]:sub( 1, 6 ) == "mouse_" then			mev[3] = ev[2]			mev[4] = ev[3] -- real x			mev[5] = ev[4] -- real y			mev[1] = "Mouse"			if ev[1] == "mouse_click" then				mev[2] = "Click"			elseif ev[1] == "mouse_drag" then				mev[2] = "Drag"				if self.data.lastEvent and self.data.lastEvent[1] == "Mouse" and ( self.data.lastEvent[2] == "Drag" or self.data.lastEvent[2] == "Click" ) then					mev[6] = mev[4] - self.data.lastEvent[4] -- x direction of drag					mev[7] = mev[5] - self.data.lastEvent[5] -- y direction of drag				end			elseif ev[1] == "mouse_scroll" then				mev[2] = "Scroll"				mev[6] = mev[3] == 1 and "up" or "down"			end			local findChild			findChild = function( parent, x, y )				if not parent.data.Children then return false end				for i = #parent.data.Children, 1, -1 do					local xx, yy = parent.data.Children[i]:getX( true ), parent.data.Children[i]:getY( true )					if x >= xx and x < xx + parent.data.Children[i]:getWidth( ) then						if y >= yy and y < yy + parent.data.Children[i]:getHeight( ) then							if parent.data.Children[i].data.handlesMouse then								return parent.data.Children[i]							end						end					end					if parent.data.Children[i].data.Children then						local c = findChild( parent.data.Children[i], x, y )						if c then							return c						end					end				end				return false			end;			mev[8] = findChild( self, ev[3], ev[4] )		elseif ev[1] == "key" or ev[1] == "char" then			mev[1] = "Keyboard"			if ev[1] == "key" then				mev[2] = "Key"				mev[3] = ev[2]				for k, v in pairs( keys ) do					if ev[2] == v then						mev[4] = k					end				end				mev[4] = mev[4] or "Unknown"			else				mev[2] = "Char"				mev[3] = keys[ev[2]]				mev[4] = ev[2]			end			local findChild			findChild = function( parent )				if not parent.data.Children then return false end				for i = #parent.data.Children, 1, -1 do					if parent.data.Children[i].data.handlesKeys then						return parent.data.Children[i]					end					if parent.data.Children[i].data.Children then						local c = findChild( parent.data.Children[i] )						if c then							return c						end					end				end				return false			end;			mev[5] = findChild( self )		end		if #mev == 0 then			for k ,v in pairs( ev ) do				mev[k] = v			end		end		for i = #self.data.Children, 1, -1 do			local ok, err = pcall( self.data.Children[i].update, self.data.Children[i], mev, self.data.lastEvent )			if not ok then				error( err, 0 )			end		end		if self.data.cb then			term.setCursorPos( self.data.ex, self.data.ey )			term.setCursorBlink( self.data.cb )		end		self.data.ex, self.data.ey = nil, nil		self.data.cb = false		if string.lower( mev[1] ) ~= "update" then			self.data.lastEvent = mev		end		return true	end;	frame.run = function( self )		term.setBackgroundColour( 32768 )		term.clear( )		self.running = true		local timer = os.startTimer( 0 )		local time = 0		local i = 0		while self.running do			i = i + 1			local ev = { os.pullEvent( ) }			if os.clock( ) - time >= 0.049 then				term.setBackgroundColour( 32768 )				term.clear( )				self:render( )				self:update( { "update", i } )				time = os.clock( )			end			if ev[1] ~= "timer" or ev[2] ~= timer then				self:update( ev )			end			if ev[1] == "timer" and ev[2] == timer then				timer = os.startTimer( 0.05 )			end		end	end	frame.data.type = "Interface"	return frameend