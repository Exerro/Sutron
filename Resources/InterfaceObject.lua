-- Core valueslocal function linewrap( str, len )	for i = 1,len do		if str:sub( i, i ) == "\n" then			return str:sub( 1, i - 1 ).." ", str:sub( i+1, str:len( ) )		end	end	if str:len( ) <= len then return str, "" end	if str:sub( len+1, len+1 ) == " " then		return str:sub( 1, len ), str:sub( len+1, str:len( ) )	end	for i = len, 1, -1 do		if str:sub( i, i ) == " " then			return str:sub( 1, i ), str:sub( i+1, str:len( ) )		end	end	return str:sub( 1, len ), str:sub( len+1, str:len( ) )endwordwrap = function( str, len, h )	local wrap	local lines = { }	while str ~= "" and ( not h or #lines < h ) do		wrap, str = linewrap( str, len )		table.insert( lines, wrap )	end	while h and #lines > h do		table.remove( lines, #lines )	end	return linesendlocal miscObject = {	getParent = function( self )		return self.data.Parent	end;	getRootParent = function( self )		local t = self		while t.data.Parent do			t = t.data.Parent		end		return t	end;	getParentByType = function( self, _type )		local t = self		while t.data.Parent do			if t.data.Parent.data.type == _type then				return t.data.Parent			end			t = t.data.Parent		end		return false	end;	getParentValues = function( self, val )		local getVal		getVal = function( self, val )			local t = { }			if self.data.Parent then				t = getVal( self.data.Parent, val )			end			table.insert( t, p.data[val] )			return t		end		return getVal( self, val )	end;	getParentNumberValues = function( self, val )		local getParentVal		getParentVal = function( p, val )			if p.data.Parent then				return getParentVal( p.data.Parent, val ) + p.data[val]			end			return p.data[val]		end		return getParentVal( self, val )	end;	getParentChild = function( self, parent ) -- used for finding a root parent that is one down from a main root parent		local findChild		findChild = function( parent, self )			for i = 1,#parent.data.Children do				if parent.data.Children[i] == self then					return true				end				if parent.data.Children[i].data.Children then					for k = 1,#parent.data.Children[i].data.Children do						if findChild( parent.data.Children[i].data.Children[k], self ) then							return true						end					end				end			end			return false		end		for i = 1,#parent.data.Children do			if findChild( parent.data.Children[i], self ) then				return parent.data.Children[i]			end		end		return false	end;	--[[ i.e, you have Parent(child1(child1(child1,child2),child2)child2(child1))	you have the handle for Parent.child1.child1.child2 and the handle for Parent	you want to get Parent.child1 and remove it for some reason	you would use self:getParentChild( Parent ):remove( )	]]	setX = function( self, x )		self.data.x = x		if self.data.solid then			if self.data.x < 1 then				self.data.x = 1			end			if self.data.Parent and self.data.x + self.data.w > self.data.Parent.data.w then				self:setWidth( self.data.Parent.data.w - self.data.x + 1 )			end		end	end;	setY = function( self, y )		self.data.y = y		if self.data.solid then			if self.data.y < 1 then				self.data.y = 1			end			if self.data.Parent and self.data.y + self.data.h > self.data.Parent.data.h then				self:setHeight( self.data.Parent.data.h - self.data.y + 1 )			end		end	end;	move = function( self, mode, x, y )		if mode == "add" then			x = x + self.data.x			y = y + self.data.y		elseif mode ~= "set" then			error( "Mode expected: [set,add]. Got "..type( mode ).." "..tostring( mode ), 2 )		end		self:setX( x )		self:setY( y )	end;	setWidth = function( self, w )		self.data.w = w		if self.data.w < 1 then			self.data.w = 1		end		if self.data.solid then			if self.data.Parent and self.data.x + self.data.w - 1 > self.data.Parent.data.w then				self.data.w = self.data.Parent.data.w - self.data.x + 1			end		end		if self.data.Children then			for k, v in pairs( self.data.Children ) do				if v.data.solid then					if v.data.x + v.data.w > self.data.w then						v:setWidth( self.data.w - v.data.x + 1 )					end					if v.data.x + v.data.w > self.data.w then						self.data.w = v.data.x + v.data.w - 1					end				end			end		end	end;	setHeight = function( self, h )		self.data.h = h		if self.data.h < 1 then			self.data.h = 1		end		if self.data.solid then			if self.data.Parent and self.data.y + self.data.h - 1 > self.data.Parent.data.h then				self.data.h = self.data.Parent.data.h - self.data.y + 1			end		end		if self.data.Children then			for k, v in pairs( self.data.Children ) do				if v.data.solid then					if v.data.y + v.data.h > self.data.h then						v:setHeight( self.data.h - v.data.y + 1 )					end					if v.data.y + v.data.h > self.data.h then						self.data.h = v.data.y + v.data.h - 1					end				end			end		end	end;	resize = function( self, mode, w, h )		if mode == "add" then			w = w + self.data.w			h = h + self.data.h		elseif mode ~= "set" then			error( "Mode expected: [set,add]. Got "..type( mode ).." "..tostring( mode ), 2 )		end		self:setWidth( w )		self:setHeight( h )	end;	fillSize = function( self )		self:resize( "set", self.data.Parent:getSize( ) )	end;		getX = function( self, real )		if not real then return self.data.x end		return self:getParentNumberValues( "x" ) - self.data.Layer	end;	getY = function( self, real )		if not real then return self.data.y end		return self:getParentNumberValues( "y" ) - self.data.Layer	end;	getPosition = function( self, real )		return self:getX( real ), self:getY( real )	end;		getWidth = function( self )		return self.data.w	end;	getHeight = function( self )		return self.data.h	end;	getSize = function( self )		return self:getWidth( ), self:getHeight( )	end;		setSolid = function( self, bool ) -- solid is used for auto resizing based on parent size		self.data.solid = not not bool	end;	isSolid = function( self )		return self.data.solid	end;	setID = function( self, id )		self.data.UID = id or self.data.UID	end;	getType = function( self )		return self.data.type	end;	activate = function( self )		self.data.active = true	end;	deactivate = function( self )		self.data.active = false	end;	toggleActive = function( self )		self.data.active = not self.data.active	end;	isActive = function( self )		return self.data.active	end;	lock = function( self )		self.data.locked = true	end;	unlock = function( self )		self.data.locked = false	end;	toggleLocked = function( self )		self.data.locked = not self.data.locked	end;	isLocked = function( self )		return self.data.locked	end;	remove = function( self )		self:deactivate( )		local i = self.data.Parent:getChildIndex( self )		if i then			table.remove( self.data.Parent.data.Children, i )		end	end;}local function newObject( Parent, _type, x, y, w, h )	local o = { }	o.data = {		type = _type;		x = 1;		y = 1;		w = 1;		h = 1;		Parent = Parent or false;		Layer = Parent and Parent.data.Layer + 1 or 0;		UID = "UNDEFINED";		active = true;		solid = true;		locked = false;	}	setmetatable( o, { __index = miscObject } )	o:move( "set", x or 1, y or 1 )	o:resize( "set", w or 1, h or 1 )	return oendlocal objectTypeslocal function newFrame( Parent )	local o = newObject( Parent, "Frame", 1, 1, 1, 1 )	o.data.Children = { }	o.newChild = function( self, Child )		table.insert( self.data.Children, Child )		Child.data.Parent = self		Child.data.Layer = self.data.Layer + 1		return Child	end	o.newFrame = function( self, x, y, w, h )		local frame = self:newChild( newFrame( self.data.Parent ) )		if x then			frame:setX( x )		end		if y then			frame:setY( y )		end		if w then			frame:setW( w )		end		if h then			frame:setH( h )		end		return frame	end	o.newObject = function( self, type )		if objectTypes[type] then			local child = objectTypes[type]:create( self )			self:newChild( child )			child.focusOn = function( self )				self.data.Parent:focus( self )			end			return child		end		return false	end	o.getChildren = function( self )		return self.data.Children	end	o.getActiveChildren = function( self )		local t = { }		for i = 1,#self.data.Children do			if self.data.Children[i].data.active then				table.insert( t, self.data.Children[i] )			end		end		return t	end	o.getChildByIndex = function( self, index )		return self.data.Children[index]	end	o.getChildByID = function( self, id )		local options = { }		for i, v in pairs( self:getActiveChildren( ) ) do			if v.data.UID == id then				table.insert( options, v )			end		end		if #options == 0 then return false, { } end		if #options == 1 then return "One", options[1] end		return "Multiple", options	end	o.getChildByType = function( self, type )		local options = { }		for i, v in pairs( self:getActiveChildren( ) ) do			if v.data.type == type then				table.insert( options, v )			end		end		if #options == 0 then return false, { } end		if #options == 1 then return "One", options[1] end		return "Multiple", options	end	o.getFirstChildByID = function( self, id )		local sel, options = self:getChildByID( id )		if not sel then return false end		if sel == "One" then return options end		return options[1]	end	o.getFirstChildByType = function( self, _type )		local sel, options = self:getChildByType( _type )		if not sel then return false end		if sel == "One" then return options end		return options[1]	end	o.getChildIndex = function( self, child )		for i = 1,#self.data.Children do			if self.data.Children[i] == child then				return i			end		end		return false	end	o.focus = function( self, child )		if type( child ) == "table" then			for k, v in pairs( self.data.Children ) do				if v == child then					child = k				end			end		end		if type( child ) == "table" then return false end -- it would be a table if it didn't find a matching child in the above loop		if not self.data.Children[child].locked then			table.insert( self.data.Children, self.data.Children[child] ) -- switcheroo			table.remove( self.data.Children, child )			if self.data.Parent then				self.data.Parent:focus( self )			end		end	end	o.update = function( self, ev, ... )		if not self.data.active then return false end		local mev = { }		for k, v in pairs( ev ) do			mev[k] = v		end		local modified = false		if type( self.data.update ) == "function" then			local ok, data = pcall( self.data.update, self, ev, ... )			if ok and data then				mev = data				modified = true			elseif not ok then				error( data, 0 )			end		end		if mev[1] == "Cancel" and modified then return false end		for i = #self.data.Children, 1, -1 do			local ok, err = pcall( self.data.Children[i].update, self.data.Children[i], mev, ... )			if not ok then				error( err, 0 )			end		end		return true	end	o.render = function( self )		if not self.data.active then return false end		local ok = true		if type( self.data.render ) == "function" then			ok = self.data.render( ) -- return false to cancel, true to continue, nil to continue			if ok == nil then ok = true end		end		if not ok then return false end		for i = 1,#self.data.Children do			self.data.Children[i]:render( )		end		return true	end	return oendobjectTypes = {	["Updater"] = {		create = function( self, Parent )			local object = newObject( Parent, "UpdaterObject" )			object.render = function( ) end			object.update = function( ) end			return object		end;	};	["Button"] = {		create = function( self, Parent ) -- self is the table i.e. objectTypes["Button"]			local object = newObject( Parent, "ButtonObject" )			object.data.handlesMouse = true			object.update = function( self, ev )				if not self.data.active then return false end				local x, y = self:getX( true ), self:getY( true )				if ev[1] == "Mouse" and ev[2] == "Down" and ev[6] == self then					self:focusOn( )					if type( self.onClick ) == "function" then						self:onClick( ev[5], ev[3], ev[4], ev[3] - x + 1, ev[4] - y + 1 )					end				end			end;			object.render = function( self )				if not self.data.active then return false end				local x, y = self:getPosition( true )				love.graphics.setColor( unpack( self.data.colour or { 255, 255, 255 } ) )				love.graphics.rectangle( "fill", x, y, self:getWidth( ), self:getHeight( ) )				love.graphics.setColor( 255, 255, 255 )			end;			return object		end;	};	["Dragable"] = {		create = function( self, Parent )			local object = newObject( Parent, "DragableObject" )			object.update = function( self, ev )				if ev[1] == "update" then					local x, y = love.mouse.getPosition( )					if love.mouse.isDown( "l" ) and self.data.lastclick then						self:move( "add", -( self.data.lastclick[1] - x ), -( self.data.lastclick[2] - y ) )						if ( self.data.lastclick[1] - x ) ~= 0 or ( self.data.lastclick[2] - y ) ~= 0 then							self.data.moved = true						end						self.data.lastclick = { x, y }					else						self.data.lastclick = false					end				elseif ev[1] == "Mouse" and ev[2] == "Down" and ev[6] == self then					local x, y, button = ev[3], ev[4], ev[5]					if button == "l" then						self.data.dragging = true						self.data.lastclick = { x, y }						self.data.moved = false					else						if self.onClick then							self:onClick( x - self:getX( true ) + 1, y - self:getY( true ) + 1, button )						end					end				elseif ev[1] == "Mouse" and ev[2] == "Up" then					local x, y, button = ev[3], ev[4], ev[5]					if self.data.lastclick and self.data.lastclick[1] == x and self.data.lastclick[2] == y and self.onClick and not self.data.moved then						self:onClick( x - self:getX( ) + 1, y - self:getY( ) + 1, button )					end					if button == "l" and ev[6] == self then						self.data.lastclick = false						self.data.moved = false						if self.onRelease then							self:onRelease( button )						end					end				end			end			object.render = function( self )				if not self.data.active then return false end				local x, y = self:getPosition( true )				love.graphics.setColor( unpack( self.data.colour or { 255, 255, 255 } ) )				love.graphics.rectangle( "fill", x, y, self:getWidth( ), self:getHeight( ) )				love.graphics.setColor( 255, 255, 255 )			end;			object.data.colour = { 155, 155, 155 }			object.data.lastclick = false			object.data.moved = false			object.data.handlesMouse = true			return object		end;	};	["Row"] = {		create = function( self, Parent )			local frame = newFrame( Parent )			frame.data.type = "RowFrame"			frame.sort = function( self )				local x = 1				for i = 1, #self.data.Children do					self.data.Children[i]:move( "set", x, 1 )					self.data.Children[i]:setHeight( self.data.h )					x = x + self.data.Children[i].data.w				end			end			frame.unpack = function( self )				local t = { }				for i = 1,#self.data.Children do					local p = self.data.Parent:newChild( self.data.Children[i] )					p:move( "add", self:getX( ) - 1, self:getY( ) - 1 )					table.insert( t, p )				end				local i = self.data.Parent:getChildIndex( self )				if i then					table.remove( self.data.Parent.data.Children, i )				end				t.remove = function( self )					for i = 1,#self do						self:deactivate( )					end				end				return t			end			return frame		end;	};	["Column"] = {		create = function( self, Parent )			local frame = newFrame( Parent )			frame.data.type = "ColumnFrame"			frame.sort = function( self )				local y = 1				for i = 1, #self.data.Children do					self.data.Children[i]:move( "set", 1, y )					self.data.Children[i]:setWidth( self.data.w )					y = y + self.data.Children[i].data.h				end			end			frame.unpack = function( self )				local t = { }				for i = 1,#self.data.Children do					local p = self.data.Parent:newChild( self.data.Children[i] )					p:move( "add", self:getX( ) - 1, self:getY( ) - 1 )					table.insert( t, p )				end				local i = self.data.Parent:getChildIndex( self )				if i then					table.remove( self.data.Parent.data.Children, i )				end				t.remove = function( self )					for i = 1,#self do						self[i]:deactivate( )					end				end				return t			end			return frame		end;	};}-- Exposed functionsfunction game.newInterface( x, y, w, h )	local frame = newFrame( )	frame:move( "set", x, y )	frame:resize( "set", w, h )	frame.update = function( self, ev )		if not self.data.active then return false end		local mev = { }		if ev[1] == "Mouse" then			local findChild			findChild = function( parent, x, y )				if not parent.data.Children then return false end				for i = #parent.data.Children, 1, -1 do					local xx, yy = parent.data.Children[i]:getPosition( true )					if x >= xx and x < xx + parent.data.Children[i]:getWidth( ) then						if y >= yy and y < yy + parent.data.Children[i]:getHeight( ) then							if parent.data.Children[i].data.handlesMouse and parent.data.Children[i].data.active then								return parent.data.Children[i]							end						end					end					if parent.data.Children[i].data.Children then						local c = findChild( parent.data.Children[i], x, y )						if c then							return c						end					end				end				return false			end;			mev[6] = findChild( self, ev[3], ev[4] )		elseif ev[1] == "Keyboard" then			local findChild			findChild = function( parent )				if not parent.data.Children then return false end				for i = #parent.data.Children, 1, -1 do					if parent.data.Children[i].data.handlesKeys then						return parent.data.Children[i]					end					if parent.data.Children[i].data.Children then						local c = findChild( parent.data.Children[i] )						if c then							return c						end					end				end				return false			end;			mev[5] = findChild( self )		end		if #mev == 0 then			for k ,v in pairs( ev ) do				mev[k] = v			end		end		for i = #self.data.Children, 1, -1 do			local ok, err = pcall( self.data.Children[i].update, self.data.Children[i], mev, self.data.lastEvent )			if not ok then				error( err, 0 )			end		end		self.data.ex, self.data.ey = nil, nil		self.data.cb = false		if string.lower( mev[1] ) ~= "update" then			self.data.lastEvent = mev		end		return true	end;	frame.run = { }	frame.run.update = function( self, dt )		self:update( { "update", dt } )	end	frame.run.mousepressed = function( self, x, y, button )		self:update( { "Mouse", "Down", x, y, button } )	end	frame.run.mousereleased = function( self, x, y, button )		self:update( { "Mouse", "Up", x, y, button } )	end	frame.run.keypressed = function( self, key, key2 )		self:update( { "Keyboard", "Down", key, key2 } )	end	frame.run.keyreleased = function( self, key, key2 )		self:update( { "Keyboard", "Up", key, key2 } )	end	frame.run.render = function( self )		return self:render( )	end	frame.data.type = "Interface"	return frameend